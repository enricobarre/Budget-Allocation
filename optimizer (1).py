# -*- coding: utf-8 -*-
"""optimizer

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1x_MHa39Jxbh8BWh1I584r87fmYU_n4P8
"""

import pandas as pd

def optimize_budget(final_investment_table, total_budget, target_regions=None):
    """
    Budget allocation algorithm (greedy) with correct unit scaling:
    - CostPerPoint must be converted from per-capita to total regional cost.
    - Budget reduction should consider population.
    """

    df_opt = final_investment_table.copy()

    # ----- 1) Filter regions if selected -----
    if target_regions and len(target_regions) > 0:
        df_opt = df_opt[df_opt["Region"].isin(target_regions)]

    # ----- 2) Convert per-capita cost → total cost per region -----
    # Must contain column "Population"
    if "Population" in df_opt.columns:
        df_opt["TotalCostPerPoint"] = df_opt["CostPerPoint"] * df_opt["Population"]
    else:
        raise ValueError("❌ ERROR: The dataframe must contain a 'Population' column!")

    # ----- 3) Sort from cheapest to most expensive investment -----
    df_opt = df_opt.sort_values(by="TotalCostPerPoint", ascending=True).reset_index(drop=True)

    remaining_budget = total_budget
    allocations, gap_reductions, residual_gaps, initial_gaps = [], [], [], []

    # ----- 4) GREEDY ALLOCATION -----
    for idx, row in df_opt.iterrows():
        initial_gap = row["Gap"]
        total_cost = row["TotalCostPerPoint"]   # €/punto per TUTTA la regione

        # budget needed to fully close the gap
        max_investment_needed = initial_gap * total_cost

        # invest as much as possible, but limited by remaining budget
        actual_investment = min(remaining_budget, max_investment_needed)
        remaining_budget -= actual_investment

        # how many OECD points were reduced?
        gap_reduction = actual_investment / total_cost if total_cost > 0 else 0
        current_residual_gap = max(0, initial_gap - gap_reduction)

        allocations.append(actual_investment)
        gap_reductions.append(gap_reduction)
        residual_gaps.append(current_residual_gap)
        initial_gaps.append(initial_gap)

        if remaining_budget <= 0:
            break

    # ----- 5) pad results if budget finished early -----
    num_allocated = len(allocations)
    if num_allocated < len(df_opt):
        allocations.extend([0] * (len(df_opt) - num_allocated))
        gap_reductions.extend([0] * (len(df_opt) - num_allocated))
        residual_gaps.extend(df_opt["Gap"].iloc[num_allocated:].tolist())
        initial_gaps.extend(df_opt["Gap"].iloc[num_allocated:].tolist())

    # ----- 6) final dataframe results -----
    df_res = df_opt.copy()
    df_res["Initial Gap"] = initial_gaps
    df_res["Allocated Budget"] = allocations
    df_res["Gap Reduction"] = gap_reductions
    df_res["Residual Gap"] = residual_gaps
    df_res["Remaining Budget"] = remaining_budget

    return df_res